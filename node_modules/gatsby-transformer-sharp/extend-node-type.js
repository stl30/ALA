"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

const Promise = require(`bluebird`);

const _require = require(`gatsby/graphql`),
      GraphQLObjectType = _require.GraphQLObjectType,
      GraphQLList = _require.GraphQLList,
      GraphQLBoolean = _require.GraphQLBoolean,
      GraphQLString = _require.GraphQLString,
      GraphQLInt = _require.GraphQLInt,
      GraphQLFloat = _require.GraphQLFloat;

const _require2 = require(`gatsby-plugin-sharp`),
      queueImageResizing = _require2.queueImageResizing,
      base64 = _require2.base64,
      fluid = _require2.fluid,
      fixed = _require2.fixed,
      traceSVG = _require2.traceSVG;

const sharp = require(`sharp`);

const fs = require(`fs`);

const fsExtra = require(`fs-extra`);

const imageSize = require(`probe-image-size`);

const path = require(`path`);

const _require3 = require(`./types`),
      ImageFormatType = _require3.ImageFormatType,
      ImageCropFocusType = _require3.ImageCropFocusType,
      DuotoneGradientType = _require3.DuotoneGradientType,
      PotraceType = _require3.PotraceType;

function toArray(buf) {
  var arr = new Array(buf.length);

  for (var i = 0; i < buf.length; i++) {
    arr[i] = buf[i];
  }

  return arr;
}

const getTracedSVG =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(function* ({
    file,
    image,
    fieldArgs
  }) {
    return traceSVG({
      file,
      args: Object.assign({}, fieldArgs.traceSVG),
      fileArgs: fieldArgs
    });
  });

  return function getTracedSVG(_x) {
    return _ref.apply(this, arguments);
  };
}();

const fixedNodeType = ({
  type,
  pathPrefix,
  getNodeAndSavePathDependency,
  reporter,
  name
}) => {
  return {
    type: new GraphQLObjectType({
      name: name,
      fields: {
        base64: {
          type: GraphQLString
        },
        tracedSVG: {
          type: GraphQLString,
          resolve: parent => getTracedSVG(parent)
        },
        aspectRatio: {
          type: GraphQLFloat
        },
        width: {
          type: GraphQLFloat
        },
        height: {
          type: GraphQLFloat
        },
        src: {
          type: GraphQLString
        },
        srcSet: {
          type: GraphQLString
        },
        srcWebp: {
          type: GraphQLString,
          resolve: ({
            file,
            image,
            fieldArgs
          }) => {
            // If the file is already in webp format or should explicitly
            // be converted to webp, we do not create additional webp files
            if (image.extension === `webp` || fieldArgs.toFormat === `webp`) {
              return null;
            }

            const args = Object.assign({}, fieldArgs, {
              pathPrefix,
              toFormat: `webp`
            });
            return Promise.resolve(fixed({
              file,
              args,
              reporter
            })).then(({
              src
            }) => src);
          }
        },
        srcSetWebp: {
          type: GraphQLString,
          resolve: ({
            file,
            image,
            fieldArgs
          }) => {
            if (image.extension === `webp` || fieldArgs.toFormat === `webp`) {
              return null;
            }

            const args = Object.assign({}, fieldArgs, {
              pathPrefix,
              toFormat: `webp`
            });
            return Promise.resolve(fixed({
              file,
              args,
              reporter
            })).then(({
              srcSet
            }) => srcSet);
          }
        },
        originalName: {
          type: GraphQLString
        }
      }
    }),
    args: {
      width: {
        type: GraphQLInt
      },
      height: {
        type: GraphQLInt
      },
      jpegProgressive: {
        type: GraphQLBoolean,
        defaultValue: true
      },
      grayscale: {
        type: GraphQLBoolean,
        defaultValue: false
      },
      duotone: {
        type: DuotoneGradientType,
        defaultValue: false
      },
      traceSVG: {
        type: PotraceType,
        defaultValue: false
      },
      quality: {
        type: GraphQLInt,
        defaultValue: 50
      },
      toFormat: {
        type: ImageFormatType,
        defaultValue: ``
      },
      cropFocus: {
        type: ImageCropFocusType,
        defaultValue: sharp.strategy.attention
      },
      rotate: {
        type: GraphQLInt,
        defaultValue: 0
      }
    },
    resolve: (image, fieldArgs, context) => {
      const file = getNodeAndSavePathDependency(image.parent, context.path);
      const args = Object.assign({}, fieldArgs, {
        pathPrefix
      });
      return Promise.resolve(fixed({
        file,
        args,
        reporter
      })).then(o => Object.assign({}, o, {
        fieldArgs: args,
        image,
        file
      }));
    }
  };
};

const fluidNodeType = ({
  type,
  pathPrefix,
  getNodeAndSavePathDependency,
  reporter,
  name
}) => {
  return {
    type: new GraphQLObjectType({
      name: name,
      fields: {
        base64: {
          type: GraphQLString
        },
        tracedSVG: {
          type: GraphQLString,
          resolve: parent => getTracedSVG(parent)
        },
        aspectRatio: {
          type: GraphQLFloat
        },
        src: {
          type: GraphQLString
        },
        srcSet: {
          type: GraphQLString
        },
        srcWebp: {
          type: GraphQLString,
          resolve: ({
            file,
            image,
            fieldArgs
          }) => {
            if (image.extension === `webp` || fieldArgs.toFormat === `webp`) {
              return null;
            }

            const args = Object.assign({}, fieldArgs, {
              pathPrefix,
              toFormat: `webp`
            });
            return Promise.resolve(fluid({
              file,
              args,
              reporter
            })).then(({
              src
            }) => src);
          }
        },
        srcSetWebp: {
          type: GraphQLString,
          resolve: ({
            file,
            image,
            fieldArgs
          }) => {
            if (image.extension === `webp` || fieldArgs.toFormat === `webp`) {
              return null;
            }

            const args = Object.assign({}, fieldArgs, {
              pathPrefix,
              toFormat: `webp`
            });
            return Promise.resolve(fluid({
              file,
              args,
              reporter
            })).then(({
              srcSet
            }) => srcSet);
          }
        },
        sizes: {
          type: GraphQLString
        },
        originalImg: {
          type: GraphQLString
        },
        originalName: {
          type: GraphQLString
        },
        presentationWidth: {
          type: GraphQLInt
        },
        presentationHeight: {
          type: GraphQLInt
        }
      }
    }),
    args: {
      maxWidth: {
        type: GraphQLInt
      },
      maxHeight: {
        type: GraphQLInt
      },
      grayscale: {
        type: GraphQLBoolean,
        defaultValue: false
      },
      jpegProgressive: {
        type: GraphQLBoolean,
        defaultValue: true
      },
      duotone: {
        type: DuotoneGradientType,
        defaultValue: false
      },
      traceSVG: {
        type: PotraceType,
        defaultValue: false
      },
      quality: {
        type: GraphQLInt,
        defaultValue: 50
      },
      toFormat: {
        type: ImageFormatType,
        defaultValue: ``
      },
      cropFocus: {
        type: ImageCropFocusType,
        defaultValue: sharp.strategy.attention
      },
      rotate: {
        type: GraphQLInt,
        defaultValue: 0
      },
      sizes: {
        type: GraphQLString,
        defaultValue: ``
      },
      srcSetBreakpoints: {
        type: GraphQLList(GraphQLInt),
        defaultValue: [],
        description: `A list of image widths to be generated. Example: [ 200, 340, 520, 890 ]`
      }
    },
    resolve: (image, fieldArgs, context) => {
      const file = getNodeAndSavePathDependency(image.parent, context.path);
      const args = Object.assign({}, fieldArgs, {
        pathPrefix
      });
      return Promise.resolve(fluid({
        file,
        args,
        reporter
      })).then(o => Object.assign({}, o, {
        fieldArgs: args,
        image,
        file
      }));
    }
  };
};

module.exports = ({
  type,
  pathPrefix,
  getNodeAndSavePathDependency,
  reporter
}) => {
  if (type.name !== `ImageSharp`) {
    return {};
  }

  const nodeOptions = {
    type,
    pathPrefix,
    getNodeAndSavePathDependency,
    reporter // TODO: Remove resolutionsNode and sizesNode for Gatsby v3

  };
  const fixedNode = fixedNodeType(Object.assign({
    name: `ImageSharpFixed`
  }, nodeOptions));
  const resolutionsNode = fixedNodeType(Object.assign({
    name: `ImageSharpResolutions`
  }, nodeOptions));
  resolutionsNode.deprecationReason = `Resolutions was deprecated in Gatsby v2. It's been renamed to "fixed" https://example.com/write-docs-and-fix-this-example-link`;
  const fluidNode = fluidNodeType(Object.assign({
    name: `ImageSharpFluid`
  }, nodeOptions));
  const sizesNode = fluidNodeType(Object.assign({
    name: `ImageSharpSizes`
  }, nodeOptions));
  sizesNode.deprecationReason = `Sizes was deprecated in Gatsby v2. It's been renamed to "fluid" https://example.com/write-docs-and-fix-this-example-link`;
  return {
    fixed: fixedNode,
    resolutions: resolutionsNode,
    fluid: fluidNode,
    sizes: sizesNode,
    original: {
      type: new GraphQLObjectType({
        name: `ImageSharpOriginal`,
        fields: {
          width: {
            type: GraphQLFloat
          },
          height: {
            type: GraphQLFloat
          },
          src: {
            type: GraphQLString
          }
        }
      }),
      args: {},

      resolve(image, fieldArgs, context) {
        return (0, _asyncToGenerator2.default)(function* () {
          const details = getNodeAndSavePathDependency(image.parent, context.path);
          const dimensions = imageSize.sync(toArray(fs.readFileSync(details.absolutePath)));
          const imageName = `${details.name}-${image.internal.contentDigest}${details.ext}`;
          const publicPath = path.join(process.cwd(), `public`, `static`, imageName);

          if (!fsExtra.existsSync(publicPath)) {
            fsExtra.copy(details.absolutePath, publicPath, err => {
              if (err) {
                console.error(`error copying file from ${details.absolutePath} to ${publicPath}`, err);
              }
            });
          }

          return {
            width: dimensions.width,
            height: dimensions.height,
            src: `${pathPrefix}/static/${imageName}`
          };
        })();
      }

    },
    resize: {
      type: new GraphQLObjectType({
        name: `ImageSharpResize`,
        fields: {
          src: {
            type: GraphQLString
          },
          tracedSVG: {
            type: GraphQLString,
            resolve: parent => getTracedSVG(parent)
          },
          width: {
            type: GraphQLInt
          },
          height: {
            type: GraphQLInt
          },
          aspectRatio: {
            type: GraphQLFloat
          },
          originalName: {
            type: GraphQLString
          }
        }
      }),
      args: {
        width: {
          type: GraphQLInt
        },
        height: {
          type: GraphQLInt
        },
        quality: {
          type: GraphQLInt,
          defaultValue: 50
        },
        jpegProgressive: {
          type: GraphQLBoolean,
          defaultValue: true
        },
        pngCompressionLevel: {
          type: GraphQLInt,
          defaultValue: 9
        },
        grayscale: {
          type: GraphQLBoolean,
          defaultValue: false
        },
        duotone: {
          type: DuotoneGradientType,
          defaultValue: false
        },
        base64: {
          type: GraphQLBoolean,
          defaultValue: false
        },
        traceSVG: {
          type: PotraceType,
          defaultValue: false
        },
        toFormat: {
          type: ImageFormatType,
          defaultValue: ``
        },
        cropFocus: {
          type: ImageCropFocusType,
          defaultValue: sharp.strategy.attention
        },
        rotate: {
          type: GraphQLInt,
          defaultValue: 0
        }
      },
      resolve: (image, fieldArgs, context) => {
        const file = getNodeAndSavePathDependency(image.parent, context.path);
        const args = Object.assign({}, fieldArgs, {
          pathPrefix
        });
        return new Promise(resolve => {
          if (fieldArgs.base64) {
            resolve(base64({
              file
            }));
          } else {
            const o = queueImageResizing({
              file,
              args
            });
            resolve(Object.assign({}, o, {
              image,
              file,
              fieldArgs: args
            }));
          }
        });
      }
    }
  };
};